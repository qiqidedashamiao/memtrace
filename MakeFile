#柏拉图平台
#CROSS = aarch64-linux-gnu-rk3588-v1-

CPP	= $(CROSS)g++
CC	= $(CROSS)gcc
LD	= $(CROSS)ld
AR  = $(CROSS)ar
RM	= rm -f
STRIP	= $(CROSS)strip

MEMTRACE_SRCPATH = ./Src
MEMTRACE_LIBPATH = ./
OBJ_PATH = ./Obj
BIN_PATH = ./

CFLAGS += -I./Include 
CFLAGS += -Wall -O2 -Os -g -ansi
CFLAGS += -D_REENTRANT -msoft-float 


#APP_LDFLAGS += -L./
APP_LDFLAGS += -Wl,-rpath,./
APP_LDFLAGS += -lpthread -lc -lrt -ldl

TEST_LDFLAGS += -O2
#优化FP寄存器，默认开启
TEST_LDFLAGS += -fomit-frame-pointer  
TEST_LDFLAGS += -rdynamic
#做backtrace最方便的就是使用gcc自带的backtrace功能，编译的时候加上-funwind-tables选项（该选项对性能无影响但是会使可执行文件略微变大），异常处理函数中调用相关函数即可输出函数调用栈，但是这依赖于你所用的编译工具链是否支持
#TEST_LDFLAGS += -funwind-tables
TEST_LDFLAGS += -g
#开启地址空间布局随机化（ASLR）
TEST_LDFLAGS += -fPIE -pie


all: share

pre:
	mkdir -p $(OBJ_PATH)

mem_log_parse: clean_server pre
	@echo "make server"
	g++ -o $(OBJ_PATH)/mem_log_parse.o -c $(MEMTRACE_SRCPATH)/mem_log_parse.cpp
	g++ -o $(BIN_PATH)/mem_log_parse $(OBJ_PATH)/mem_log_parse.o $(APP_LDFLAGS)

clean_server:
	$(RM) $(BIN_PATH)/server $(OBJ_PATH)/mem_log_parse.o

clean:
	$(RM) $(BIN_PATH)/mem_log_parse $(OBJ_PATH)/mem_log_parse.o ./a.out $(MEMTRACE_LIBPATH)/*.so $(MEMTRACE_SRCPATH)/*.o
	
share:
	g++ -shared -fpic -g -o libpreload.so memTraceDy.cpp --std=c++11 -lpthread -ldl -DUSE_DEP=10

test:
	g++ -o sonia test.cpp --std=c++11 -lpthread -ldl $(TEST_LDFLAGS)